---
// Render tabular data.

import { isAnchorProps } from '../component_props/Anchor'
import { isEntityProps } from '../component_props/Entity'
import { isPeriodProps } from '../component_props/Period'
import { isPfDateProps } from '../component_props/PfDate'
import { isPostProps } from '../component_props/Post'
import type { TableProps } from '../component_props/Table'
import { isTechStackProps } from '../component_props/TechStack'
import type { ColumnSpec } from '../types/table'
import Anchor from './Anchor.astro'
import Entity from './Entity.astro'
import Period from './Period.astro'
import PfDate from './PfDate.astro'
import Post from './Post.astro'
import TechStack from './TechStack.astro'

const {
  table: { rows, columnSpecs, expandingColumn },
  class: className,
  ...attrs
} = Astro.props as TableProps<Record<string, ColumnSpec>>
---

<table class:list={['pf-table', className]} {...attrs}>
  <thead>
    <tr>
      {
        Object.entries(columnSpecs).map(
          ([columnId, { title, class: className }]) => (
            <th class:list={[{ fit: expandingColumn !== columnId }, className]}>
              {title}
            </th>
          ),
        )
      }
    </tr>
  </thead>
  <tbody>
    {
      rows.map((row, idx, allRows) => {
        const isLastSibling =
          idx < allRows.length - 1 && row.groupId !== allRows[idx + 1]?.groupId
        return (
          <tr class:list={[{ 'last-of-group': isLastSibling }]} {...row.attrs}>
            {Object.entries(columnSpecs).map(
              ([columnId, { renderer, class: className }]) => {
                const cellValue = row.data[columnId]
                return (
                  <td
                    class:list={[
                      { fit: expandingColumn !== columnId },
                      className,
                    ]}>
                    {cellValue === undefined && import.meta.env.DEV ? (
                      <span class="dev" title="Only visible during dev">
                        und
                      </span>
                    ) : renderer === 'Anchor' && isAnchorProps(cellValue) ? (
                      <Anchor {...cellValue}>link</Anchor>
                    ) : renderer === 'PfDate' && isPfDateProps(cellValue) ? (
                      <PfDate {...cellValue} />
                    ) : renderer === 'Entity' && isEntityProps(cellValue) ? (
                      <Entity {...cellValue} />
                    ) : renderer === 'Period' && isPeriodProps(cellValue) ? (
                      <Period {...cellValue} />
                    ) : renderer === 'TechStack' &&
                      isTechStackProps(cellValue) ? (
                      <TechStack {...cellValue} />
                    ) : renderer === 'Post' && isPostProps(cellValue) ? (
                      <Post {...cellValue} />
                    ) : (
                      // Renderer is 'Text'.
                      cellValue
                    )}
                  </td>
                )
              },
            )}
          </tr>
        )
      })
    }
  </tbody>
</table>

<style>
  @layer pf.components {
    .pf-table {
      margin-inline: -1rem;
      inline-size: calc(100% + 2rem);

      th,
      td {
        border-inline: none; /* vs `pf.universal` */

        &.fit {
          inline-size: 1px;
          white-space: nowrap;
        }
      }

      th {
        border-start-start-radius: 0; /* vs `pf.universal` */
        border-start-end-radius: 0; /* vs `pf.universal` */
        text-transform: lowercase;
      }

      td {
        .dev {
          color: var(--pf-color-fg-subtle);
          font-family: var(--pf-font-family-monospace);
          text-decoration: line-through;
        }
      }

      tr:last-child td {
        border-end-start-radius: 0; /* vs `pf.universal` */
        border-end-end-radius: 0; /* vs `pf.universal` */
      }

      tr.inactive td * {
        opacity: 0.5;
      }

      .last-of-group td {
        border-block-end: 1px dashed var(--pf-color-border);
      }

      .align-end {
        text-align: end;
      }

      /*
       * If a table is the last child, we don't need the bottom margin and we
       * also remove the bottom border to allow for the parent to place its own
       * divider instead.
       */
      &:last-child {
        margin-block-end: 0;

        tr:last-child td {
          border-block-end: 0;
        }
      }
    }
  }
</style>
